---
title: "Microsoft Flow - Alert Bot"
date:   2019-04-03 20:00:00
categories: [Automation]
tags: [Automation, Slack, Cyber]
---

### Introduction

In this walkthrough, I'll describe how I used Microsoft Flow to perform several security related tasks saving time for our security teams when responding to alerts. We'll be re-using a lot of the items referenced in my previous post about [Starting Tenable scans with a Code-Less Slack Bot](https://jasonlazerus.com/2019/codeless-slack-bot/). One notable difference in this flow is that we'll be creating numerous empty variables up front. The reason for this is because we'll be using a lot of Condition actions and you cannot initialize a new variable within a Condition.

### Takeaways

This is a pretty lengthy flow and is actually the 2nd version I've created. It is easily expandable and currently performs the following tasks.

1. Detects when a new alert ticket is created (using SalesForce in this example).
2. Parses the type of alert that has been generated.
3. Parses specific data out of each alert including IP Address and Username.
4. Pulls whois data.
5. Offers to contain a device (using Crowdstrike).
6. Starts an approval process to validate alert actions were intentional and not caused by account takeover.

### Variables

Use this as a reference after the initial trigger is created. All of these should be considered string variables unless otherwise noted.

* AlertSource
* Approver
* CaseDesciption
* CaseID
* CaseNumber
* Continue (Boolean)
* Domain
* EMailAddress
* FirstName
* LastName
* Username
* User
* AdminEmail
* ServiceAccount
* SourceIP
* DestinationIP
* Port
* SlackStatement

### Flow

Upon creating a new flow, you'll have to choose a Trigger action. In my case, I'm looking for a new case created in a specific SalesForce queue.

![](/images/posts/alert-bot/step1.png "Trigger")

Then, initialize all of the variables mentioned above. Be sure to name both the variable and the action appropriately. 

![](/images/posts/alert-bot/step2.png "Variables")

Next, each AlertSource will need its own Condition action. You don't _need_ to give each AlertSource its own separate action and _can_ nest them, however you may run into an issue if you have a lot of alert sources as the maximum number of nesting levels is 12. Before you begin creating these Conditions, make sure you know how to differentiate each of these alert types. For every example below, I will only be using the 'If yes' fields. I am intentionally going to leave the 'If no' fields empty since I do not want to nest these Conditions until I reach the 'Continue' action.

![](/images/posts/alert-bot/step3.png "Condition1")
![](/images/posts/alert-bot/step4.png "Condition2")

Since each of these sources are different, they each need to be parsed separately.

#### Continue

If you created all the variables listed above, you'll notice one called 'Continue'. We're going to use that variable in a Condition action to end the flow depending on the type of AlertSource. Let's create that now since some of the AlertSources below will not continue after they take action.

Create a new Condition action and choose the 'Continue' variable, then set the 'trigger' to 'true'.

![](/images/posts/alert-bot/continue.png "Continue")

#### Crowdstrike

Create a new Condition action __above__ the Continue action.

To start the Crowdstrike portion of this flow, I begin by setting the AlertSource variable to 'CrowdStrike' and the Continue variable to 'false'.

![](/images/posts/alert-bot/step5.png "Crowdstrike1")

Next, I'll parse the hostname from the subject of the case since that's how its sent by the vendor. In this case, the hostname is the last word in the Subject line. To extract this, I create a Compose action with the following statement. This will get the last word of the variable 'Subject' when split with a space.

`last(split(triggerBody()?['Subject'],' '))`

At this point, I'm going to send a Slack notification to a channel I already have setup via an incoming webhook. This notification lets the security team that an alert has been generated for the extracted hostname and also gives the case number and URL for the case.

![](/images/posts/alert-bot/step6.png "Crowdstrike2")

This part is nice but it's just a notification and my goal is to speed up response. Let's add a button that an analyst can click on that can contain a host. To do so, we'll need Oauth2 credentials from Crowdstrike and we'll have to make a few HTTP requests to get the data needed prior to offering a button. The first HTTP request below will be for the access_token, which we'll then need to parse using the 'Parse JSON' action.

![](/images/posts/alert-bot/step7.png "Crowdstrike3")

```
{
    "type": "object",
    "properties": {
        "access_token": {
            "type": "string"
        },
        "token_type": {
            "type": "string"
        },
        "expires_in": {
            "type": "integer"
        }
    }
}
```

With the token_type and access_token, you can now request the `aid` (agent ID) from Crowdstrike which you'll need to be able to contain a device. To do this, you'll query the API with the hostname as shown in the image below.

![](/images/posts/alert-bot/step8.png "Crowdstrike4")

Next, create another 'Parse JSON' action using the schema below and the Content as the Body of the previous HTTP request.

```
{
    "type": "object",
    "properties": {
        "meta": {
            "type": "object",
            "properties": {
                "query_time": {
                    "type": "number"
                },
                "pagination": {
                    "type": "object",
                    "properties": {
                        "offset": {
                            "type": "integer"
                        },
                        "limit": {
                            "type": "integer"
                        },
                        "total": {
                            "type": "integer"
                        }
                    }
                },
                "powered_by": {
                    "type": "string"
                },
                "trace_id": {
                    "type": "string"
                }
            }
        },
        "resources": {
            "type": "array",
            "items": {
                "type": "string"
            }
        },
        "errors": {
            "type": "array"
        }
    }
}
```

From this response, we are going to build the JSON body for the Slack message. Start by creating a new Compose action. Feel free to use the JSON below as a starter changing whatever text you want. I recommend replacing the 'HOSTNAME' on the "text" object below with your hostname variable. Also, note that under the "actions" below, I have two choices (Contain and Skip Containment). For the Contain "value", you'll need to insert "resources" object that was created as a result of parsing the previous JSON statement. Note: It will appear as though this part of your flow has now changed. This is expected as the resource value is an array and under normal circumstances, can have multiple values. Flow is assuming this is the case and is dropping it into an 'apply to each' statement. Do not delete this statement or this will not work.

![](/images/posts/alert-bot/step9.png "Crowdstrike5")

```
{
  "text": "Would you like to contain HOSTNAME in Crowdstrike?",
  "attachments": [
    {
      "text": "",
      "fallback": "Please view this message in the Slack app.",
      "callback_id": "contain",
      "color": "danger",
      "attachment_type": "default",
      "actions": [
        {
          "name": "choice",
          "text": "Contain",
          "type": "button",
          "style": "danger",
          "value": ""
        },
        {
          "name": "choice",
          "text": "Skip Containment",
          "type": "button",
          "value": "skip"
        }
      ]
    }
  ]
}
```

Next, we can send the Slack message by creating an HTTP action. Use the same Slack webhook from earlier as the URI and set the Body to the JSON you just created. 

![](/images/posts/alert-bot/step10.png "Crowdstrike6")

If this was done correctly, your slack post should look like this.

![](/images/posts/alert-bot/step11.png "Crowdstrike7")

Since we set the Continue variable to false and we're not using any of the 'If no' conditions above the Continue action, this flow will end intentionally. We still need to build the 2nd part of the flow for the actual Contain action.

__Save this flow before continuing.__

To contain a host in Crowdstrike using this method, we're actually going to create a second separate much shorter flow. Create a new flow in Microsoft Flow and as the trigger action, choose 'Request'. Then name your flow and hit save. This should generate a URI for you to use with your button. We'll finish this flow before creating the interactive component in Slack.

Next, you'll want to create your 'Response' object because Slack needs a response within 3000ms. 

![](/images/posts/alert-bot/2-1.png "Request")

We'll need to do a bunch of `application/x-www-form-urlencoded` parsing for this so we'll start by setting the body of the above request to a string variable.

![](/images/posts/alert-bot/2-2.png "StringBody")

For each of these items within the string body, we'll create a Scope action (just for easier reading and moving if necessary). 

![](/images/posts/alert-bot/2-3.png "Scope")

##### Get Button Decision

You may have to adjust these to fit your response.

Compose 1: Find the index of the first character in the decision.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'interactive_message\",\"actions\":[{\"name\":\"choice\",\"type\":\"button\",\"value\":\"')), 92)`

Compose 2: Find the index of the last character in the decision.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'callback_id')),-5)`

Compose 3: Find the length of the decision.
`sub(outputs('Get_Index_of_callback'),outputs('Get_First_Index'))`

Compose 4: Get the substring of the decision and decode it.
`substring(decodeUriComponent(variables('RequestBody')),outputs('Get_First_Index'),outputs('Get_Last_Index'))`

***

##### Get Agent ID

Compose 1: Find the index of the first character in the Agent ID.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'danger')), -43)`

Compose 2: Find the index of the last character in the Agent ID.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'danger')), -11)`

Compose 3: Find the length of the Agent ID.
`sub(outputs('Agent_Get_Danger_Index'),outputs('Agent_First_Index'))`

Compose 4: Get the substring of the Agent ID and decode it.
`substring(decodeUriComponent(variables('RequestBody')),outputs('Agent_First_Index'),outputs('Agent_Get_Last_Index'))`

***

##### Get Hostname

Compose 1: Find the index of the first character in the hostname.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'to contain ')), 11)`

Compose 2: Find the index of the last character in the hostname.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), ' in Crowdstrike?')), 0)`

Compose 3: Find the length of the hostname.
`sub(outputs('Get_Index_of_In_Crowdstrike'),outputs('Get_Index_of_Hostname'))`

Compose 4: Get the substring of the hostname and decode it.
`substring(decodeUriComponent(variables('RequestBody')),outputs('Get_Index_of_Hostname'),outputs('Get_Last_Index_-_Hostname'))`

***

##### Get User (who clicked on the button)

Compose 1: Find the index of the first character in the username.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'user')), 32)`

Compose 2: Find the index of the last character in the username.
`add(int(indexOf(decodeUriComponent(variables('RequestBody')), 'action_ts')), -4)`

Compose 3: Find the length of the username.
`sub(outputs('User_-_Get_Second_Index'),outputs('User_-_Get_First_Index'))`

Compose 4: Get the substring of the username and decode it.
`substring(decodeUriComponent(variables('RequestBody')),outputs('User_-_Get_First_Index'),outputs('User_-_Get_Last_Index'))`

***

Next, create a Condition action to check if the user chose to Contain or Skip Containment.

![](/images/posts/alert-bot/2-4.png "Skip")

For the `If yes` option, we'll get a new Crowdstrike Token, create a JSON message and send the HTTP POST to contain the host.

![](/images/posts/alert-bot/step7.png "Crowdstrike3")

```
{
    "type": "object",
    "properties": {
        "access_token": {
            "type": "string"
        },
        "token_type": {
            "type": "string"
        },
        "expires_in": {
            "type": "integer"
        }
    }
}
```

Using the below JSON text, send the HTTP post to the URI in the image below.

```
{
  "action_parameters": [
    {
      "name": "name",
      "value": "contain"
    }
  ],
  "ids": [
    "@{outputs('Agent_ID')}"
  ]
}
```

![](/images/posts/alert-bot/2-5.png "Contain")

Next, we'll verify that the request was successful. If it is successful, we're sending notifications to multiple channels (IncidentResponse, Desktop Support, and the channel where the alert button is (so no one else clicks on it)).

Create a new Condition action using the Status Code of the HTTP request above and check that its equal to 202. If it is, the containment request was successful and you can send your notifications. You can send the same JSON text to multiple channels.

![](/images/posts/alert-bot/2-6.png "Notification")

If the Status Code does not equal 202, then you can create a similar notification stating that the Containment request was unsuccessful and that it requires manual followup. The same can be done if the containment was skipped in the previous Condition action.

##### Interactive Component

The final item needed for this flow to work is to create a new Interactive Component in Slack. Once you create the item, use the Request URL from this new flow in the Request URL of the Interactive Component and turn it on.

This concludes the Crowdstrike section of this flow.

#### SIEM

TBC